package it.unibo.pokerogue.utilities;

import java.io.IOException;
import java.lang.reflect.InvocationTargetException;
import java.util.ArrayList;
import java.util.List;
import java.util.Optional;

import it.unibo.pokerogue.model.api.GraphicElementsRegistry;
import it.unibo.pokerogue.model.api.item.Item;
import it.unibo.pokerogue.model.api.pokemon.Pokemon;
import it.unibo.pokerogue.model.api.trainer.Trainer;
import it.unibo.pokerogue.model.enums.Stats;
import it.unibo.pokerogue.model.impl.graphic.TextElementImpl;
import it.unibo.pokerogue.model.impl.item.ItemFactoryImpl;
import it.unibo.pokerogue.model.impl.trainer.PlayerTrainerImpl;

/**
 * Utility class for handling various helper functions and constants used in the
 * SceneShop.
 * This includes managing shop item generation, updating UI elements like item
 * names,
 * prices, and player-related display texts.
 *
 * <p>
 * This class is not meant to be instantiated and contains only static methods
 * and constants.
 * </p>
 */
public final class SceneShopUtilities {
    private static final String QUESTION_MARK_STRING = "???";
    private static final List<Item> SHOP_ITEMS = new ArrayList<>();
    private static final Integer PRICY_ITEMS_SIZE = 3;
    private static final Integer FREE_ITEMS_SIZE = 3;
    private static final Integer PRICY_ITEM_1_NAME_POSITION = 111;
    private static final Integer PRICY_ITEM_1_PRICE_POSITION = 105;
    private static final Integer FREE_ITEM_1_NAME_POSITION = 108;

    private SceneShopUtilities() {
        // Utility class shouldn't be instanciated
    }

    /**
     * Retrieves the name of the Pokémon at a given position in the trainer's team.
     *
     * @param trainer  The trainer whose Pokémon list is queried.
     * @param position The index in the team.
     * @return The name of the Pokémon or "???" if not present.
     */
    public static String getPokemonNameAt(final Trainer trainer, final int position) {
        return trainer.getPokemon(position)
                .map(Pokemon::getName)
                .orElse(QUESTION_MARK_STRING);
    }

    /**
     * Builds a string representing the current and maximum HP of a Pokémon at a
     * specific team position.
     *
     * @param position              Index of the Pokémon in the team.
     * @param playerTrainerInstance The player trainer instance containing the
     *                              Pokémon team.
     * @return A string in the format "current / max", or "??? / ???" if
     *         unavailable.
     */
    public static String getPokemonLifeText(final int position, final PlayerTrainerImpl playerTrainerInstance) {
        final Optional<Pokemon> pokemonOpt = playerTrainerInstance.getPokemon(position);

        if (!pokemonOpt.isPresent()) {
            return "??? / ???";
        }

        final Pokemon pokemon = pokemonOpt.get();
        final Integer currentHp = pokemon.getActualStats().get(Stats.HP).getCurrentValue();
        final Integer maxHp = pokemon.getActualStats().get(Stats.HP).getCurrentMax();

        return currentHp + " / " + maxHp;
    }

    /**
     * Initializes the list of shop items by clearing the current items
     * and adding a predefined number of random items generated by the provided item
     * factory.
     * 
     * The first {@code PRICY_ITEMS_SIZE} items are considered pricy,
     * followed by {@code FREE_ITEMS_SIZE} free items.
     *
     * @param itemFactory the {@link ItemFactoryImpl} instance used to generate
     *                    random items
     */
    public static void initShopItems() throws IOException,
            InstantiationException,
            IllegalAccessException,
            NoSuchMethodException,
            InvocationTargetException {
        final ItemFactoryImpl itemFactory = ItemFactoryImpl.getInstance(ItemFactoryImpl.class);

        SHOP_ITEMS.clear();
        for (int i = 0; i < PRICY_ITEMS_SIZE; i++) {
            SHOP_ITEMS.add(itemFactory.randomItem());
        }
        for (int i = 0; i < FREE_ITEMS_SIZE; i++) {
            SHOP_ITEMS.add(itemFactory.randomItem());
        }
    }

    /**
     * Returns the shop item located at the specified index.
     *
     * @param index the index of the item to retrieve from the shop's item list
     * @return the {@link Item} at the given index
     * @throws IndexOutOfBoundsException if the index is out of range (index < 0 ||
     *                                   index >= SHOP_ITEMS.size())
     */
    public static Item getShopItems(final int index) {
        return SHOP_ITEMS.get(index);
    }

    /**
     * Updates the item description text element in the scene's graphic elements
     * registry.
     * Sets the text of the UI element named "ITEM_DESCRIPTION_TEXT" to the
     * description of the provided item.
     *
     * @param sceneGraphicElements the registry of graphic elements for the current
     *                             scene
     * @param item                 the {@link Item} whose description will be
     *                             displayed
     */
    public static void updateItemDescription(final GraphicElementsRegistry sceneGraphicElements, final Item item) {
        UtilitiesForScenes.safeGetElementByName(sceneGraphicElements, "ITEM_DESCRIPTION_TEXT",
                TextElementImpl.class)
                .setText(item.getDescription());
    }

    /**
     * Updates the names and prices of all shop items in the UI.
     * Also sets their X positions dynamically based on their index.
     *
     * @param sceneGraphicElements Registry containing the UI elements to be
     *                             updated.
     */
    public static void updateItemsText(final GraphicElementsRegistry sceneGraphicElements) {

        for (int i = 0; i < PRICY_ITEMS_SIZE; i++) {
            final Item item = getShopItems(i);
            final double xPosition = 0.15 + (i * 0.29);
            final double xPositionPrice = 0.25 + (i * 0.29);

            UtilitiesForScenes.safeGetElementById(sceneGraphicElements, PRICY_ITEM_1_NAME_POSITION + i,
                    TextElementImpl.class)
                    .setText(item.getName());
            UtilitiesForScenes.safeGetElementById(sceneGraphicElements, PRICY_ITEM_1_NAME_POSITION + i,
                    TextElementImpl.class)
                    .setLeftX(xPosition);

            UtilitiesForScenes.safeGetElementById(sceneGraphicElements, PRICY_ITEM_1_PRICE_POSITION + i,
                    TextElementImpl.class)
                    .setText(String.valueOf(item.getPrice()));
            UtilitiesForScenes.safeGetElementById(sceneGraphicElements, PRICY_ITEM_1_PRICE_POSITION + i,
                    TextElementImpl.class)
                    .setLeftX(xPositionPrice);
        }
        for (int i = 0; i < FREE_ITEMS_SIZE; i++) {
            final Item item = getShopItems(FREE_ITEMS_SIZE + i);

            final double xPosition = 0.18 + (i * 0.29);

            UtilitiesForScenes.safeGetElementById(sceneGraphicElements, FREE_ITEM_1_NAME_POSITION + i,
                    TextElementImpl.class)
                    .setText(item.getName());
            UtilitiesForScenes.safeGetElementById(sceneGraphicElements, FREE_ITEM_1_NAME_POSITION + i,
                    TextElementImpl.class)
                    .setLeftX(xPosition);
        }
    }

    /**
     * Updates the displayed amount of money the player has.
     *
     * @param sceneGraphicElements  Registry containing the UI elements for the
     *                              scene.
     * @param playerTrainerInstance The player whose money value is displayed.
     */
    public static void updatePlayerMoneyText(final GraphicElementsRegistry sceneGraphicElements,
            final PlayerTrainerImpl playerTrainerInstance) {
        UtilitiesForScenes.safeGetElementByName(sceneGraphicElements, "PLAYER_MONEY_TEXT",
                TextElementImpl.class)
                .setText("MONEY: " + playerTrainerInstance.getMoney());
    }

}
